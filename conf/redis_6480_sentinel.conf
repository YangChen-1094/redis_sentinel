port 26480
daemonize yes
logfile "26480.log"
dir "/root/myRedis/master"

sentinel myid 0fd3a90d2eccd83bb5332a70c064219e61190fbc
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 127.0.0.1 6480 2
sentinel failover-timeout mymaster 15000
#sentinel auth-pass mymaster 123

#sentinel monitor <master-name> <ip> <redis-port> <quorum>
#告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效
#
#sentinel auth-pass <master-name> <password>
#设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。
#
#sentinel down-after-milliseconds <master-name> <milliseconds>
#这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒
#
#sentinel parallel-syncs <master-name> <numslaves> 
#这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
#
#sentinel failover-timeout <master-name> <milliseconds>
#failover-timeout 可以用在以下这些方面：    
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。  
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。   
#3.当想要取消一个正在进行的failover所需要的时间。   
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。
# Generated by CONFIG REWRITE
protected-mode no
sentinel config-epoch mymaster 1
sentinel leader-epoch mymaster 1
sentinel known-replica mymaster 127.0.0.1 6481
sentinel known-replica mymaster 127.0.0.1 6479
sentinel known-sentinel mymaster 127.0.0.1 26479 d4a37020c85b66709927dc62962a9c219e6159d0
sentinel known-sentinel mymaster 127.0.0.1 26481 a41a277fe42c95c698610a6646fdaab26ef7e09c
sentinel current-epoch 1
